# Задание 1 — Анализ производительности CPU-параллельной программы (OpenMP)

## 1. Цель задания

Нужно разработать программу на C++ с использованием **OpenMP**, которая обрабатывает большой массив данных и вычисляет статистики:

- сумму `sum`,
- среднее `mean`,
- дисперсию `var`.

Далее требуется:

- реализовать **последовательную версию** (baseline),
- реализовать **параллельную версию** с OpenMP,
- выполнить **профилирование** через `omp_get_wtime()` (в коде именно так),
- исследовать влияние **числа потоков** на ускорение,
- оценить долю последовательной и параллельной частей и интерпретировать результаты через **закон Амдала**.

---

## 2. Что делает программа

Программа:

1. Создаёт массив `a` размера `N` и заполняет его случайными числами (0..1).
2. Считает статистики **последовательно**:
   - одним циклом накапливает `sum` и `sumsq`,
   - затем вычисляет `mean = sum/N`,
   - и дисперсию `var = (sumsq/N) - mean^2`.
3. Считает те же статистики **параллельно** для разных чисел потоков:
   - использует OpenMP `parallel for` с `reduction`,
   - замеряет время выполнения,
   - считает ускорение и эффективность.
4. Для каждого числа потоков оценивает **последовательную долю `s`** по закону Амдала и выводит:
   - время,
   - ускорение,
   - эффективность,
   - оценку `s` и `1 - s`.

---

## 3. Идея решения

### 3.1 Последовательная версия (baseline)
Последовательная функция `stats_sequential(...)` делает один проход по массиву и считает:

- `sum = Σ a[i]`
- `sumsq = Σ a[i]^2`

Далее:

- `mean = sum / N`
- `var = (sumsq / N) - mean * mean`

Время вычислений замеряется через `omp_get_wtime()`.

### 3.2 Параллельная версия (OpenMP)
Параллельная функция `stats_parallel(...)` использует:

- `#pragma omp parallel for num_threads(threads) reduction(+:sum,sumsq) schedule(static)`

Ключевой момент: `reduction(+:sum,sumsq)` гарантирует корректное суммирование результатов всех потоков в две общие переменные.

После цикла вычисления `mean` и `var` выполняются уже последовательно (это маленькая последовательная часть).

---

## 4. Профилирование и что измеряется

Используется `omp_get_wtime()`:

- измеряется **время инициализации массива** (создание + заполнение),
- измеряется **чистое время вычислений статистики** (в sequential и parallel вариантах).

Важно: в таблице сравнения используется именно `Sequential compute (s)` и `Par time (s)` — то есть сравниваются времена **вычислительной части**, а не генерация данных.

---

## 5. Влияние числа потоков

Программа автоматически формирует список потоков:

- `1, 2, 4, 8, ...` до `max_threads`,
- если `max_threads` не степень двойки — добавляет его отдельно.

Для каждого `t`:

- замеряется время параллельного вычисления,
- считается ускорение: `Speedup = t_seq / t_par`,
- считается эффективность: `Eff(%) = (Speedup / t) * 100`.

---

## 6. Доля последовательной и параллельной части: закон Амдала

Закон Амдала:

`S(p) = 1 / ( s + (1 - s)/p )`

где:
- `S(p)` — ускорение на `p` потоках,
- `s` — доля **последовательной** части (0..1),
- `(1 - s)` — доля **параллельной** части.

В коде из измеренного ускорения `speedup` и числа потоков `p` вычисляется `s`:

`amdahl_serial_fraction(speedup, p)`

После чего печатаются:

- `Amdahl serial s` — оценка последовательной доли,
- `Parallel part (1-s)` — оценка параллельной доли.

Интерпретация:
- если `s` близко к 0 → программа почти полностью параллелится,
- если `s` заметное → ускорение будет быстро “упираться в потолок”.

---

## 7. Проверка корректности

Чтобы убедиться, что параллельная версия считает те же результаты, что и последовательная, программа вычисляет максимальную разницу между:

- `sum`,
- `mean`,
- `var`

и помечает строки как корректные (если ошибка мала).  
Это важно, потому что параллельные суммирования могут давать небольшие отличия из-за порядка сложения (floating-point).

---

## 8. Что выводит программа

Программа выводит:

- параметры запуска: `N` и `max_threads`,
- время инициализации массива,
- время вычислений в последовательной версии,
- результаты последовательной версии (sum/mean/var),
- таблицу для разных потоков, где есть:
  - число потоков,
  - параллельное время,
  - ускорение,
  - эффективность,
  - оценка последовательной доли `s` по Амдалу и параллельной доли `(1-s)`.
